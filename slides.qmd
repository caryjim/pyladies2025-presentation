---
author: "Cary K. Jim, Ph.D." 
title: "Stratified Sampling in Survey Research with Python"
subtitle: "PyLadiesCon 2025"
date: "Dec 2025"

format:
    revealjs:
        slide-number: true
        code-fold: true

jupyter: python3
---

::: notes
**Abstract:** Stratified sampling helps ensure representative data subsets, especially when working with imbalanced groups. In this talk, weâ€™ll explore its use in survey analysis, demonstrate Python-based implementation, and share best practices for improving data reliability and reducing bias. Attendees will gain a clear understanding of when and how to use stratified sampling effectively in real-world scenarios.

**Description:** Whether you're conducting surveys, building predictive models, or working with imbalanced datasets, stratified sampling is a powerful technique to ensure your data is representative and your insights are reliable.

In survey research, especially within diverse populations like college students, simple random sampling can lead to under-representation of key subgroups. Stratified sampling addresses this by dividing the population into distinct strata (e.g., age groups, majors, demographics) and sampling proportionally from each. This approach reduces sampling bias and improves the reliability of statistical estimates.

In this presentation, I will demonstrate how to use Python to implement stratified sampling in a student survey at our college. By maintaining proportional representation across age groups, we ensured that our sample reflected the diversity of the student body. Iâ€™ll walk through the conceptual foundations of stratified sampling, compare it with simple random sampling, and highlight its advantages in survey research and data analysis.

Weâ€™ll also explore how to calculate weighted means when sample proportions differ from population proportions, which is a crucial step in producing unbiased estimates. Code examples and visualizations will be shared via GitHub to support hands-on learning and reproducibility.
:::

# Introduction

## Learning Outcomes: {.smaller .scrollable}

1.  Understand when to use stratified sampling over random sampling

2.  Learn how to define subgroups (strata) and implement sampling in Python

3.  Evaluate sample representativeness by checking distribution patterns

4.  Apply weights to adjust for unequal proportions in score estimation

**Assumptions of the audience**

-   Some familiarity with descriptive statistics and sampling frameworks

-   Basic understanding of Python programming language

-   Interest in data analysis and research methodologies

Today's presentation uses **stratified random sampling** to identify subgroups proportional to the student population in one semester.

## What is Stratified Sampling and Its Application?

::: notes
When there is a large population to study, it is impossible to survey everyone because in reality we are always limited by time, budget, or other resources. The use of simple random sampling may comes to mind, and depends on your research objectives, this method may not be the best approach if you want to be able to apply the results to inform programs, policies, or other initiatives. Last, designing research with stratification allows for analysis of differences across key demographic or behavioral segments. In sum, stratified sampling can reduce sampling bias/errors, and improve the precision of estimates. It is also more efficient than simple random sampling for heterogeneous populations.
:::

-   Challenges in surveying large populations

-   Aligning research outcomes with actionable goals

-   Enhancing insight discovery through subgroup analysis

## Stratified Sampling Overview {.smaller}

Stratified sampling is a research design method that involves dividing a population into smaller subgroups known as strata.

-   Strata are formed based on shared attributes or characteristics (e.g., age group, gender, geographic location).

-   A sampling technique, such as random, systematic, or convenience sampling, is then applied to select participants in each stratum.

ðŸ“˜ Example

1.  Systematic sampling with strata: You divided a college students population based on their major and then select every *k*th element based on your the size needed from each stratum.

2.  Stratified random sampling: You divided a college students population based on their major and then randomly select a proportionate number of students from each major.

# Today's Topic: Stratified Random Sampling

## Procedures {.smaller}

-   Start with the population dataset and identify the variables for stratification. The variables should be distinct, non-overlapping groups, e.g., Age, Gender, Race.

-   Determine the required sample size (i.e., total observations) you need for your study.

    -   We will use proportional allocation today where each stratum's representation matches to its proportion in the population.

    -   Another approach is optimal allocation, which increase the sample size for a specific strata that is important to the research.

-   Select the random samples from each stratum and combine all strata to form the complete sample group.

## Implementation Steps with Python

1.  Define the population and identify relevant strata and its proportions.
2.  Determine the sample size for each stratum based on its proportion in the overall population.
3.  Randomly select samples by each stratum according to the calculated proportions.
4.  Combine the selected samples from all strata to form the final sample group.
5.  Examine the sample distribution and adjust strata definitions if needed.

::: notes
**About the Dataset:**

The participant dataset used in this presentation is synthetic, modeled after a realistic student population in a small college. It was created specifically for demonstration purposes. To illustrate the stratified sampling process and decision-making involved in research design, I selected a few key demographic variables: **race, age/age group, and gender** and will discuss more in-depth in today's presentation. The full dataset and code are available in the GitHub repository linked at the end of the presentation.
:::

## Step 1: Identify the strata and its proportions {.smaller .scrollable}

In this example, the population is defined as 25,000 college students.

**Variables in the population dataset:**

```{python}
# Hide this code chunk in the presentation
#| echo: false
import pandas as pd
data_folder = './Data Files/'
population_data = pd.read_csv(data_folder + "synthetic_students.csv")
```

```{python}
population_data.head()
```

-   Four categorical variables: gender, race, ethnicity, and student type

-   Two numerical variables: age and overall GPA

-   Select the most relevant variables and some re-coding would be necessary

    -   Race and gender

    -   Re-code age to Age Group

::: notes
Notes: We begin by defining our populationâ€”25,000 college students in this example. Next, we assess the distribution of potential strata in the dataset. The dataset includes three categorical variables: race, ethnicity, and gender, and two numerical variables: age and overall GPA. Since weâ€™re working with multiple variables, we need to re-code some of them to create meaningful strata. This helps ensure that the strata are both analytically useful and aligned with the research objectives. At this stage, we also decide which variables are most relevant to our study. Not all variables may be necessary, so we focus on those that best support our research goals. This step is crucial because each stratum will be used in weight calculations during analysis. It also becomes especially important when the final respondent group doesnâ€™t perfectly reflect the population structure, allowing us to adjust and maintain representativeness.
:::

## Step 2. Determine the sample size and proportions of each subgroup {.smaller}

**2.1 Cochran's Sample Size**

Commonly use method is survey research or studies in educational settings

**There are two steps in this process:**

1.  Apply Cochran's ideal sample size formula with a set of parameters for a desired level of precision.

2.  Use the obtained ideal sample size value in the modified formula for finite population (i.e., The student population size is known) to get the adjusted sample size.

## Cochran's sample size formula {.smaller .scrollable}

The ideal sample size for an infinite population is given by: 
$$
n_0 = \frac{Z^2 \, p \, (1 - p)}{e^2}
$$ 

where:

-   ( n~0~ ) = initial sample size from Cochranâ€™s formula for an infinite population
-   ( Z ) = Z-value (e.g., 1.96 for 95% confidence, z-table lookup)
-   ( p ) = estimated proportion of the attribute present in the population (assuming 0.5 for largest variability)
-   ( e ) = margin of error (e.g., 0.05 for 5%, the desired level of precision)

The sample size adjusted for a finite population is given by: 

$$
n = \frac{n_0}{1 + \left( \frac{n_0 - 1}{N} \right)}
$$ 

where:

-   ( n ) = adjusted sample size for a finite population
-   ( n~0~ ) = theoretical sample value obtained from Cochranâ€™s formula for an infinite population
-   ( N ) = population size

## 2.2 Code example: Cochran's sample size calculation {.smaller .scrollable}

```{python}
#| echo: true

# Cochran's Sample Size Calculation
import scipy.stats as stats
def cochran_sample_size(Z, p, e, N):
    n0 = (Z**2 * p * (1 - p)) / (e**2)
    n = n0 / (1 + ((n0 - 1) / N))
    return int(n)

# Parameters
Z = stats.norm.ppf(0.975)   # Calculate the critical z-value for a 95% confidence level in a standard normal distribution
p = 0.5                     # Estimated proportion (use 0.5 for maximum variability, sort of like worst-case scenario)
e = 0.05                    # Margin of error (precision level, more precision requires larger sample size)
N = 25000                   # Finite population size (in this example, student population size)

# Calculate sample size

# Calculate n0 and adjusted sample size for finite population
n0 = (Z**2 * p * (1 - p)) / (e**2)
sample_size = n0 / (1 + ((n0 - 1) / N))
print(f"Ideal sample size (n0): {round(n0)}")
print(f"Adjusted sample size for finite population: {int(sample_size)}")

```

The result from the code above shows that the ideal sample size for an infinite population is 384, and the adjusted sample size for our finite population of 25,000 students is 378. Next, we will use this adjusted sample size to determine how many students we need from each subgroup (strata) in the population.

::: notes
In this slide, weâ€™re introducing Cochranâ€™s Sample Size Formula, a widely used method in educational and survey research to determine how many participants are needed for statistically valid results. We start with the ideal sample size formula for an infinite population. This formula uses three key parameters:

Z-value, which corresponds to the desired confidence level (e.g., 1.96 for 95% confidence), p, the estimated proportion of the population with the attribute of interest (we often use 0.5 to account for maximum variability), and e, the margin of error weâ€™re willing to accept (commonly 0.05 for 5%).

Once we calculate the ideal sample size, we adjust it for a finite populationâ€”in our case, 25,000 college studentsâ€”using a modified formula. This ensures our sample size is appropriate for the actual population size. The Python code example demonstrates how to implement this calculation programmatically. It uses the scipy.stats library to compute the Z-value and then applies both formulas to get the ideal and adjusted sample sizes. This process helps ensure that our survey results are both accurate and representative of the population weâ€™re studying.
:::

## Re-code Age to Age Group {.smaller}
:::: {.columns}

::: {.column width="50%"}
**Example 1: By increments of 2 or 10**
```{python}
#| echo: true

# Binding age groups by increments of 2 years for younger ages and 10 years for older ages
population_data['Age_Group_1'] = pd.cut(population_data['Age'], 
                                       bins=[17, 19, 21, 23, 25, 27, 29, 31, 41, 50],
                                       labels=['17-18', '19-20', '21-22', '23-24', '25-26', '27-28', '29-30', '31-40', '41-50'], right=False)
# View the first 3 records to confirm the new Age_Group variable
population_data[['Age', 'Age_Group_1']].head(3)
```
:::

::: {.column width="50%"}
**Example 2: By meaningful groups**
```{python}
#| echo: true

# Re-code Age by meaningful groups, such as typical college age, graduate age, and then beyond.

# We will keep the first three groups like the previous example, but then group all older ages into one group, as 31 and above, ' 31+

population_data['Age_Group_2'] = pd.cut(population_data['Age'], 
                                       bins=[17, 19, 21, 23, 25, 30, 44],
                                       labels=['17-18', '19-20', '21-22', '23-25', '26-30', '31+'],
                                   right=False)
# View the last 5 records to confirm the new Age_Group variable
population_data[['Age', 'Age_Group_2']].tail(5)
```
:::

::::

In the first example, any groups beyond the age of 40 is really small, and the population size for age 23 or above is much smaller by proportion to the younger age groups. The second example levels the age group more appropriately and has a decent count at each level. 

Remember we still need to use this information to calculate proportion and so in practice, you may repeat this steps and the sampling part until you are able to draw a proper set of subgroups as a final complete sample.

## Step 3: Select random samples by each stratum by the calculated proportions {.smaller .scrollable}

```{python}
#| echo: false

# Other recoding
# We will make a copy of the required variables and form a new DataFrame
sample_selection_data = population_data[['StudentID', 'Gender', 'Race', 'Age_Group_2']].copy()
# For Gender, we would like to remove the 'Unknown' category and make a new column for the modified values.
sample_selection_data['Gender_m'] = sample_selection_data['Gender'].replace({'Unknown': None})
# For Race, we can combine 'American Indian or Alaska Native' with the 'Native Hawaiian or Other Pacific Islander', into a single 'Other' category.
sample_selection_data['Race_m'] = sample_selection_data['Race'].replace({'American Indian or Alaska Native': 'Other',
                                                          'Native Hawaiian or Other Pacific Islander': 'Other'})
# Remove Unknown from Race, Race_m is the modified column
sample_selection_data['Race_m'] = sample_selection_data['Race_m'].replace({'Unknown': None})
```


The strata (subgroups) are determined by the following categories:

-   Gender (Female or Male)

-   Race (Asian, Black or African American, White, Two or more races, Other)

-   Age Group (16-18, 19-20, 21-22, 23-30, 31+)

```{python}
#| echo: true
# Proportion of Gender in the Sample Selection Data
print(sample_selection_data['Gender_m'].value_counts(normalize=True).round(2))
print()
# Proportion of Race in the Sample Selection Data
print(sample_selection_data['Race_m'].value_counts(normalize=True).round(2))
print()
# Proportion of Age Group in the Sample Selection Data
print(sample_selection_data['Age_Group_2'].value_counts(normalize=True).round(2))
```

Note. You can review the jupyter notebook in the GitHub Repo that shows the iteration of determine the proportion of each stratum.
```{python}
#| echo: false


# This time we are using a different set of parameters. The formula remains the same from Step 2.
# Parameters
Z = stats.norm.ppf(0.975)   # Calculate the critical z-value for
# a 95% confidence level in a standard normal distribution
p = 0.5                     # Estimated proportion (use 0.5 for maximum variability, sort of like worst-case scenario)
e_3 = 0.03                    # Margin of error (precision level, more precision requires larger sample size)
N = 25000                   # Finite population size (in this example, student population size)

# Calculate sample size
# Calculate n0 and adjusted sample size for finite population
n0 = (Z**2 * p * (1 - p)) / (e_3**2)
sample_size_larger_e = n0 / (1 + ((n0 - 1) / N))
print(f"Ideal sample size (n0) for 95% confidence level with 3% margin of error: {round(n0)}")
print(f"Adjusted sample size of finite population for 95% confidence level with 3% margin of error: {int(sample_size_larger_e)}")

# Determine the combined proportions of the strata in the sample selection data with the modified variables
stratum_set_1 = sample_selection_data.groupby(['Gender_m', 'Race_m', 'Age_Group_2'], observed=True).size().reset_index(name='Count')
stratum_set_1['Proportion'] = stratum_set_1['Count'] / stratum_set_1['Count'].sum()


# use the 3% sample size to draw the stratified random sample
stratum_sizes_three_moe = (stratum_set_1['Proportion'] * int(sample_size_larger_e)).round().astype(int)
# Add the grouping variables back to the stratum sizes DataFrame for clarity
stratum_sizes_three_moe = pd.concat([stratum_set_1[['Gender_m', 'Race_m', 'Age_Group_2']], stratum_sizes_three_moe.rename('Sample_Size')], axis=1)

```

::: {notes}
Due to time constraints, we will not go through the entire iterative process of defining strata and calculating proportions in detail. However, I encourage you to explore the Jupyter notebook available in the GitHub repository linked at the end of this presentation. The notebook provides a comprehensive walkthrough of how to iteratively refine strata definitions and calculate their proportions within the population. For now, we will proceed with the final strata definitions and their corresponding proportions to demonstrate the sampling process.
:::

## Step 4. Apply random selection by each strata and form the completed sample dataset {.smaller .scrollable}

```{python}
#| echo: true

# Initialize an empty list to hold sampled dataframes
sampled_groups = []
for i, row in stratum_sizes_three_moe.iterrows():
    stratum_filter = (
        (sample_selection_data['Gender_m'] == row['Gender_m']) &
        (sample_selection_data['Race_m'] == row['Race_m']) &
        (sample_selection_data['Age_Group_2'] == row['Age_Group_2'])
    )
    stratum_population = sample_selection_data[stratum_filter]
    # Use the sample size from the current row
    stratum_sample_size = int(row['Sample_Size'])

    # Ensure we don't sample from empty strata or more than available
    n = min(stratum_sample_size, len(stratum_population))
    if n > 0:
        stratum_sample = stratum_population.sample(n=n, replace=False)
        sampled_groups.append(stratum_sample)

# Combine all sampled dataframes into a single dataframe (guard against empty list)
if sampled_groups:
    sampled_dataset = pd.concat(sampled_groups).reset_index(drop=True)
else:
    sampled_dataset = pd.DataFrame(columns=sample_selection_data.columns)

# Create an alias expected by downstream cells and align column naming
sampled_data = sampled_dataset.copy()
if 'Age_Group' not in sampled_data.columns and 'Age_Group_2' in sampled_data.columns:
    sampled_data['Age_Group'] = sampled_data['Age_Group_2']

sampled_dataset.head()
```


::: {.notes}
In this code snippet, we perform the random selection of samples from each stratum based on the calculated sample sizes. We initialize an empty DataFrame to hold the sampled data. Then, we iterate through each row of the strata proportions DataFrame. For each stratum, we filter the population data to get the subset corresponding to the current stratum. We then randomly sample the specified number of participants from this subset using the sample method, allowing for replacement to ensure we can meet the required sample size even if the stratum is small.
Finally, we concatenate the sampled stratum data to our main sampled_data DataFrame. After processing all strata, we reset the index of the sampled_data DataFrame to ensure it is clean and sequential. The resulting DataFrame contains our final stratified random sample, which accurately reflects the population structure based on our defined strata.
:::

## Step 5. Check the proportion of the sampled data to the population data {.smaller .scrollable}

:::: {.columns}

::: {.column width="50%"}
**Sampled Dataset (n = 378)**
```{python}
# Calculate the proportions in the sampled data
sample_proportions = sampled_dataset.groupby(['Gender_m', 'Race_m', 'Age_Group_2'], observed=True).size().reset_index(name='Count')
sample_proportions['Proportion'] = sample_proportions['Count'] / sample_proportions['Count'].sum()
sample_proportions.head(10)
# What you want to do is compare the 'Proportion' column in sample_proportions with the population proportions.
```
:::

::: {.column width="50%"}
**Population Dataset (N = 25,000)**
```{python}
# Calculate the proportions in the population data
population_proportions = sample_selection_data.groupby(['Gender_m', 'Race_m', 'Age_Group_2'], observed=True).size().reset_index(name='Count')
population_proportions['Proportion'] = population_proportions['Count'] / population_proportions['Count'].sum()
population_proportions.head(10)
```
:::
::::

::: {.notes}
In this slide, we compare the proportions of each stratum in both the sampled dataset and the population dataset to ensure that our stratified sampling process has accurately reflected the population structure. On the left, we display the proportions from the sampled dataset, which consists of 378 participants. We group the sampled data by Gender, Race, and Age Group, calculate the counts for each stratum, and then compute their proportions relative to the total sample size. On the right, we show the proportions from the population dataset of 25,000 students, following the same grouping and calculation process. By comparing these two sets of proportions, we can verify that our stratified sampling has successfully maintained the representativeness of the population within our sample.
:::

# Weight Calculation for Survey Analysis (.smaller .scrollable)

The use of weights is essential when the sample proportions differ from the population proportions. This adjustment helps to correct for any over- or under-representation of certain groups in the sample, ensuring that the analysis reflects the true population structure.

Depending on the number of stratification variables and their levels, weights can be calculated for each stratum or for combined categories. The formular for calculating weights for combined categories is similar to calculating weights for individual strata, but it takes into account the joint distribution of the combined categories.

## Weights Calculation Formula {.smaller .scrollable}
In general, the formula for calculating weight for each category is:

$$
\text{Weight} = \frac{\text{Proportion from Sample Group}}{\text{Proportion from Respondent Group}}
$$

Because we used a combination of variables in the strata, each participant should be assigned an overall weight:

$$
W_{\text{overall}} = W_{\text{race}} \times W_{\text{gender}} \times W_{\text{age}}
$$

Each weight is determined by dividing the sample groups' proportion by the respondent groups' proportion for each category, and then multiplying these weights together to get the overall weight for each participant.

The overall weight assigned to each respondent is then used to calculate the individual item score on the survey. The unadjusted means and the weighted mean scores are often compared as well to see if there are any significant differences.

## Code Example of Weight Calculation {.smaller .scrollable}

```{python}
#| echo: false
# Import the respondents data file (synthetic respondents data based on a survey)
import pandas as pd
data_folder = './Data Files/'
respondents_data = pd.read_excel(data_folder +'respondents_file.xlsx')
respondents_data.head()
```

Examine the respondents data and the proportions of each stratum.
```{python}
#| echo: true

# Demographic proportions of the three variables: Gender, Race, and Age Group and create a dictionary by the proportion and round to three decimal places
respondent_proportions = {
    "Gender_r": respondents_data['Q1_Gender'].value_counts(normalize=True).round(3).to_dict(),
    "Race_r": respondents_data['Q2_Race'].value_counts(normalize=True).round(3).to_dict(),
    "Age_Group_r": respondents_data['Q3_AgeGroup'].value_counts(normalize=True).round(3).to_dict()
}
respondent_proportions
```


::: {.notes}
In this code snippet, we calculate the population proportions for each stratum defined by Gender, Race, and Age Group. We group the population data by these categories and compute the counts for each stratum. Then, we calculate the proportion of each stratum relative to the total population size. This information is crucial for the subsequent weight calculation, as it allows us to determine how well each stratum is represented in our sample compared to the overall population.
:::

# Extension of Stratified Random Sampling

## Handling Imbalanced Classes in Classification Tasks

Use **stratified sampling** to ensure each class is proportionally represented in training and testing datasets

-   Prevents bias toward majority classes

-   improves model performance and generalization

## Survey Planning with Response Rate Consideration

Although we designed the sample group of students to survey is within 400, however, we don't often get all 400 results back. Therefore, adjust invitation count based on **expected response rate** can also be implemented.

Example: If desired sample size is **2,000** and historical response rate is **10%**, you should increase the sample size by 10% to reach more participants. 

# GitHub Repo & Contact Me
-   GitHub Repository: [GitHub Repository](https://github.com/your-repo)
-   Contact Me: [Email](mailto:your-email@example.com)
-   LinkedIn: [LinkedIn Profile](https://www.linkedin.com/in/your-profile)
-   Twitter: [Twitter Handle](https://twitter.com/your-handle)
-   Instagram (food, travel, and cat photos): [Instagram Profile](https://www.instagram.com/your-profile)

Thank you for attending my presentation!
