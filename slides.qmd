---
author: "Cary K. Jim, Ph.D." 
title: "Stratified Sampling in Survey Research with Python"
subtitle: "PyLadiesCon 2025"
date: "Dec 2025"

format:
    revealjs:
        slide-number: true
        code-fold: true

jupyter: python3
---

::: notes
**Abstract:** Stratified sampling helps ensure representative data subsets, especially when working with imbalanced groups. In this talk, weâ€™ll explore its use in survey analysis, demonstrate Python-based implementation, and share best practices for improving data reliability and reducing bias. Attendees will gain a clear understanding of when and how to use stratified sampling effectively in real-world scenarios.

**Description:** Whether you're conducting surveys, building predictive models, or working with imbalanced datasets, stratified sampling is a powerful technique to ensure your data is representative and your insights are reliable.

In survey research, especially within diverse populations like college students, simple random sampling can lead to under-representation of key subgroups. Stratified sampling addresses this by dividing the population into distinct strata (e.g., age groups, majors, demographics) and sampling proportionally from each. This approach reduces sampling bias and improves the reliability of statistical estimates.

In this presentation, I will demonstrate how to use Python to implement stratified sampling in a student survey at our college. By maintaining proportional representation across age groups, we ensured that our sample reflected the diversity of the student body. Iâ€™ll walk through the conceptual foundations of stratified sampling, compare it with simple random sampling, and highlight its advantages in survey research and data analysis.

Weâ€™ll also explore how to calculate weighted means when sample proportions differ from population proportions, which is a crucial step in producing unbiased estimates. Code examples and visualizations will be shared via GitHub to support hands-on learning and reproducibility.
:::

# Introduction

## Learning Outcomes: {.smaller .scrollable}

1.  Understand when to use stratified sampling over random sampling

2.  Learn how to define subgroups (strata) and implement sampling in Python

3.  Evaluate sample representativeness by checking distribution patterns

4.  Apply weights to adjust for unequal proportions in score estimation

**Assumptions of the audience**

-   Some familiarity with descriptive statistics and sampling frameworks

-   Basic understanding of Python programming language

-   Interest in data analysis and research methodologies

Today's presentation uses **stratified random sampling** to identify subgroups proportional to the student population in one semester.

## What is Stratified Sampling and Its Application?

::: notes
When there is a large population to study, it is impossible to survey everyone because in reality we are always limited by time, budget, or other resources. The use of simple random sampling may comes to mind, and depends on your research objectives, this method may not be the best approach if you want to be able to apply the results to inform programs, policies, or other initiatives. Last, designing research with stratification allows for analysis of differences across key demographic or behavioral segments. In sum, stratified sampling can reduce sampling bias/errors, and improve the precision of estimates. It is also more efficient than simple random sampling for heterogeneous populations.
:::

-   Challenges in surveying large populations

-   Aligning research outcomes with actionable goals

-   Enhancing insight discovery through subgroup analysis

## Stratified Sampling Overview {.smaller}

Stratified sampling is a research design method that involves dividing a population into smaller subgroups known as strata.

-   Strata are formed based on shared attributes or characteristics (e.g., age group, gender, geographic location).

-   A sampling technique, such as random, systematic, or convenience sampling, is then applied to select participants in each stratum.

ðŸ“˜ Example

1.  Systematic sampling with strata: You divided a college students population based on their major and then select every *k*th element based on your the size needed from each stratum.

2.  Stratified random sampling: You divided a college students population based on their major and then randomly select a proportionate number of students from each major.

# Today's Topic: Stratified Random Sampling

## Procedures {.smaller}

-   Start with the population dataset and identify the variables for stratification. The variables should be distinct, non-overlapping groups, e.g., Age, Gender, Race.

-   Determine the required sample size (i.e., total observations) you need for your study.

    -   We will use proportional allocation today where each stratum's representation matches to its proportion in the population.

    -   Another approach is optimal allocation, which increase the sample size for a specific strata that is important to the research.

-   Select the random samples from each stratum and combine all strata to form the complete sample group.

## Implementation Steps with Python

1.  Define the population and identify relevant strata and its proportions.
2.  Determine the sample size for each stratum based on its proportion in the overall population.
3.  Randomly select samples by each stratum according to the calculated proportions.
4.  Combine the selected samples from all strata to form the final sample group.
5.  Examine the sample distribution and adjust strata definitions if needed.

::: notes
**About the Dataset:**

The participant dataset used in this presentation is synthetic, modeled after a realistic student population in a small college. It was created specifically for demonstration purposes. To illustrate the stratified sampling process and decision-making involved in research design, I selected a few key demographic variables: **race, age/age group, and gender** and will discuss more in-depth in today's presentation. The full dataset and code are available in the GitHub repository linked at the end of the presentation.
:::

## Step 1: Identify the strata and its proportions {.smaller .scrollable}

In this example, the population is defined as 25,000 college students.

**Variables in the population dataset:**

```{python}
# Hide this code chunk in the presentation
#| echo: false
import pandas as pd
population_data = pd.read_csv("synthetic_students.csv")
```

```{python}
population_data.head()
```

-   Four categorical variables: gender, race, ethnicity, and student type

-   Two numerical variables: age and overall GPA

-   Select the most relevant variables and some re-coding would be necessary

    -   Race and gender

    -   Re-code age to Age Group

::: notes
Notes: We begin by defining our populationâ€”25,000 college students in this example. Next, we assess the distribution of potential strata in the dataset. The dataset includes three categorical variables: race, ethnicity, and gender, and two numerical variables: age and overall GPA. Since weâ€™re working with multiple variables, we need to re-code some of them to create meaningful strata. This helps ensure that the strata are both analytically useful and aligned with the research objectives. At this stage, we also decide which variables are most relevant to our study. Not all variables may be necessary, so we focus on those that best support our research goals. This step is crucial because each stratum will be used in weight calculations during analysis. It also becomes especially important when the final respondent group doesnâ€™t perfectly reflect the population structure, allowing us to adjust and maintain representativeness.
:::

## Step 2. Determine the sample size and proportions of each subgroup {.smaller}

**2.1 Cochran's Sample Size**

Commonly use method is survey research or studies in educational settings

**There are two steps in this process:**

1.  Apply Cochran's ideal sample size formula with a set of parameters for a desired level of precision.

2.  Use the obtained ideal sample size value in the modified formula for finite population (i.e., The student population size is known) to get the adjusted sample size.

## Cochran's sample size formula {.smaller .scrollable}

The ideal sample size for an infinite population is given by: $$
n_0 = \frac{Z^2 \, p \, (1 - p)}{e^2}
$$ where:

-   ( n~0~ ) = initial sample size from Cochranâ€™s formula for an infinite population
-   ( Z ) = Z-value (e.g., 1.96 for 95% confidence, z-table lookup)
-   ( p ) = estimated proportion of the attribute present in the population (assuming 0.5 for largest variability)
-   ( e ) = margin of error (e.g., 0.05 for 5%, the desired level of precision)

The sample size adjusted for a finite population is given by: $$
n = \frac{n_0}{1 + \left( \frac{n_0 - 1}{N} \right)}
$$ where:

-   ( n ) = adjusted sample size for a finite population
-   ( n~0~ ) = theoretical sample value obtained from Cochranâ€™s formula for an infinite population
-   ( N ) = population size

## 2.2 Code example: Cochran's sample size calculation {.smaller .scrollable}

```{python}
#| echo: true

# Cochran's Sample Size Calculation
import scipy.stats as stats
def cochran_sample_size(Z, p, e, N):
    """
    Calculate the required sample size using Cochran's formula, adjusted for a finite population.

    Parameters:
        Z (float): Z-value (e.g., 1.96 for 95% confidence level)
Z = stats.norm.ppf(0.975)   # Z-score for the upper tail of a two-tailed 95% confidence interval (1.96 for 95% confidence)
        e (float): Margin of error (e.g., 0.05 for 5%)
        N (int): Population size

    Returns:
        int: Adjusted sample size for the finite population
    """
    n0 = (Z**2 * p * (1 - p)) / (e**2)
    n = n0 / (1 + ((n0 - 1) / N))
    return int(n)

# Parameters
Z = stats.norm.ppf(0.975)   # Calculate the critical z-value for a 95% confidence level in a standard normal distribution
p = 0.5                     # Estimated proportion (use 0.5 for maximum variability, sort of like worst-case scenario)
e = 0.05                    # Margin of error (precision level, more precision requires larger sample size)
N = 25000                   # Finite population size (in this example, student population size)

# Calculate sample size

# Calculate n0 and adjusted sample size for finite population
n0 = (Z**2 * p * (1 - p)) / (e**2)
sample_size = n0 / (1 + ((n0 - 1) / N))
print(f"Ideal sample size (n0): {round(n0)}")
print(f"Adjusted sample size for finite population: {int(sample_size)}")

```

The result from the code above shows that the ideal sample size for an infinite population is 384, and the adjusted sample size for our finite population of 25,000 students is 378. Next, we will use this adjusted sample size to determine how many students we need from each subgroup (strata) in the population.

::: notes
In this slide, weâ€™re introducing Cochranâ€™s Sample Size Formula, a widely used method in educational and survey research to determine how many participants are needed for statistically valid results. We start with the ideal sample size formula for an infinite population. This formula uses three key parameters:

Z-value, which corresponds to the desired confidence level (e.g., 1.96 for 95% confidence), p, the estimated proportion of the population with the attribute of interest (we often use 0.5 to account for maximum variability), and e, the margin of error weâ€™re willing to accept (commonly 0.05 for 5%).

Once we calculate the ideal sample size, we adjust it for a finite populationâ€”in our case, 25,000 college studentsâ€”using a modified formula. This ensures our sample size is appropriate for the actual population size. The Python code example demonstrates how to implement this calculation programmatically. It uses the scipy.stats library to compute the Z-value and then applies both formulas to get the ideal and adjusted sample sizes. This process helps ensure that our survey results are both accurate and representative of the population weâ€™re studying.
:::

## Re-code Age to Age Group {.smaller}
:::: {.columns}

::: {.column width="50%"}
**Example 1: By increments of 2 or 10**
```{python}
#| echo: true
# Recode Age to Age Group
population_data['Age_Group'] = pd.cut(population_data['Age'], 
                                       bins=[16, 19, 21, 23, 25, 27, 29, 31, 41, 51, 61, 81],
                                       labels=['16-18', '19-20', '21-22', '23-24', '25-26', '27-28', '29-30', '31-40', '41-50', '51-60', '61-80'],
                                   right=False)
population_data[['Age', 'Age_Group']].head(10)

# Age group distribution
population_data['Age_Group'].value_counts().sort_index()
```
:::

::: {.column width="50%"}
**Example 2: By meaningful groups**
```{python}
#| echo: true

# Ensure Age_Group is categorical dtype
if not pd.api.types.is_categorical_dtype(population_data['Age_Group']):
    population_data['Age_Group'] = population_data['Age_Group'].astype('category')

# Remove unused categories and add any missing ones to avoid errors
population_data['Age_Group'] = population_data['Age_Group'].cat.remove_unused_categories()
new_categories = {
    '23-24': '23-30',
    '25-26': '23-30',
    '27-28': '23-30',
    '29-30': '23-30',
    '31-40': '31+',
    '41-50': '31+',
    '51-60': '31+',
    '61-80': '31+'
}
population_data['Age_Group'] = population_data['Age_Group'].replace(new_categories)
population_data['Age_Group'].value_counts().sort_index()
```
:::

::::

In the first example, any groups beyond the age of 40 is really small, and the population size for age 23 or above is much smaller by proportion to the younger age groups. The second example levels the age group more appropriately and has a decent count at each level. 

Remember we still need to use this information to calculate proportion and so in practice, you may repeat this steps and the sampling part until you are able to draw a proper set of subgroups as a final complete sample.

## Step 3: Select random samples by each stratum by the calculated proportions {.smaller .scrollable}

The strata (subgroups) are determined by the following categories:

-   Gender (Female or Male)

-   Race (Asian, Black or African American, White, Two or more races, Other)

-   Age Group (16-18, 19-20, 21-22, 23-30, 31+)

Note. You can review the jupyter notebook in the GitHub Repo that shows the iteration of determine the proportion of each stratum.

::: {notes}
Due to time constraints, we will not go through the entire iterative process of defining strata and calculating proportions in detail. However, I encourage you to explore the Jupyter notebook available in the GitHub repository linked at the end of this presentation. The notebook provides a comprehensive walkthrough of how to iteratively refine strata definitions and calculate their proportions within the population. For now, we will proceed with the final strata definitions and their corresponding proportions to demonstrate the sampling process.
:::

## 3.1 Code example: Calculate proportions and apply it to select stratum {.smaller .scrollable}

```{python}
#| echo: true
# Calculate proportions for each stratum
strata_counts = population_data.groupby(['Gender', 'Race', 'Age_Group']).size()
strata_proportions = strata_counts / len(population_data)
strata_proportions = strata_proportions.reset_index(name='Proportion')
strata_proportions.head()

# Sample size for each stratum
total_sample_size = 378  # From Cochran's calculation
strata_proportions['Sample_Size'] = (strata_proportions['Proportion'] * total_sample_size).round().astype(int)
strata_proportions.head()
```
::: {.notes}
In this code snippet, we first calculate the counts of each stratum by grouping the population data based on the defined categories:
Gender, Race, and Age Group. We then compute the proportions of each stratum relative to the total population size. This gives us a clear understanding of how each subgroup is represented within the overall population.
Next, we determine the sample size for each stratum by multiplying its proportion by the total sample size we calculated earlier using Cochran's formula. The resulting sample sizes are rounded to the nearest integer to ensure we have whole numbers of participants for each stratum. This step is crucial for ensuring that our sample accurately reflects the population structure.
:::

## Step 4. Apply random selection by each strata and form the completed sample dataset {.smaller .scrollable}

```{python}
#| echo: true
# Randomly select samples from each stratum
sampled_data = pd.DataFrame()
for _, row in strata_proportions.iterrows():
    stratum = population_data[
        (population_data['Gender'] == row['Gender']) &
        (population_data['Race'] == row['Race']) &
        (population_data['Age_Group'] == row['Age_Group'])
    ]
    sampled_stratum = stratum.sample(n=row['Sample_Size'], replace=True)
    sampled_data = pd.concat([sampled_data, sampled_stratum])
sampled_data.reset_index(drop=True, inplace=True)
sampled_data.head()
```
::: {.notes}
In this code snippet, we perform the random selection of samples from each stratum based on the calculated sample sizes. We initialize an empty DataFrame to hold the sampled data. Then, we iterate through each row of the strata proportions DataFrame. For each stratum, we filter the population data to get the subset corresponding to the current stratum. We then randomly sample the specified number of participants from this subset using the sample method, allowing for replacement to ensure we can meet the required sample size even if the stratum is small.
Finally, we concatenate the sampled stratum data to our main sampled_data DataFrame. After processing all strata, we reset the index of the sampled_data DataFrame to ensure it is clean and sequential. The resulting DataFrame contains our final stratified random sample, which accurately reflects the population structure based on our defined strata.
:::

## Step 5. Check the proportion of the sampled data to the population data {.smaller .scrollable}

:::: {.columns}

::: {.column width="50%"}
**Sampled Dataset (n = 378)**
```{python}
sampled_stratum_counts = sampled_data.groupby(['Gender', 'Race', 'Age_Group'], observed=True).size().reset_index(name='Count')
sampled_stratum_counts['Proportion'] = sampled_stratum_counts['Count'] / sampled_stratum_counts['Count'].sum()
sampled_stratum_counts[['Gender', 'Race', 'Age_Group', 'Proportion']].head(5)
```
:::

::: {.column width="50%"}
**Population Dataset (N = 25,000)**
```{python}
population_counts = population_data.groupby(['Gender', 'Race', 'Age_Group']).size().reset_index(name='Count')
population_counts['Proportion'] = population_counts['Count'] / population_counts['Count'].sum()
population_counts[['Gender', 'Race', 'Age_Group', 'Proportion']].head(5)
```
:::
::::

::: {.notes}
In this slide, we compare the proportions of each stratum in both the sampled dataset and the population dataset to ensure that our stratified sampling process has accurately reflected the population structure. On the left, we display the proportions from the sampled dataset, which consists of 378 participants. We group the sampled data by Gender, Race, and Age Group, calculate the counts for each stratum, and then compute their proportions relative to the total sample size. On the right, we show the proportions from the population dataset of 25,000 students, following the same grouping and calculation process. By comparing these two sets of proportions, we can verify that our stratified sampling has successfully maintained the representativeness of the population within our sample.
:::

# Weights Calculation

The use of weights is essential when the sample proportions differ from the population proportions. This adjustment helps to correct for any over- or under-representation of certain groups in the sample, ensuring that the analysis reflects the true population structure.

Depending on the number of stratification variables and their levels, weights can be calculated for each stratum or for combined categories. The formular for calculating weights for combined categories is similar to calculating weights for individual strata, but it takes into account the joint distribution of the combined categories.

## Weights Calculation Formula and Code Example {.smaller .scrollable}

Weight = (Population Proportion) / (Sample Proportion)

```{python}
#| echo: true
# Calculate population proportions for weight calculation
population_counts = population_data.groupby(['Gender', 'Race', 'Age_Group']).size().reset_index(name='Count')
population_counts['Proportion'] = population_counts['Count'] / population_counts['Count'].sum()
population_counts.head(10)
```
::: {.notes}
In this code snippet, we calculate the population proportions for each stratum defined by Gender, Race, and Age Group. We group the population data by these categories and compute the counts for each stratum. Then, we calculate the proportion of each stratum relative to the total population size. This information is crucial for the subsequent weight calculation, as it allows us to determine how well each stratum is represented in our sample compared to the overall population.
:::

# Extension of Stratified Random Sampling

## Handling Imbalanced Classes in Classification Tasks

Use **stratified sampling** to ensure each class is proportionally represented in training and testing datasets

-   Prevents bias toward majority classes

-   improves model performance and generalization

## Survey Planning with Response Rate Consideration

Although we designed the sample group of students to survey is within 400, however, we don't often get all 400 results back. Therefore, adjust invitation count based on **expected response rate** can also be implemented.

Example: If desired sample size is **2,000** and historical response rate is **10%**, then:\

InvitationsÂ Required=20000\* 10=20,000


# GitHub Repo & Contact Me
-   GitHub Repository: [GitHub Repository](https://github.com/your-repo)
-   Contact Me: [Email](mailto:your-email@example.com)
-   LinkedIn: [LinkedIn Profile](https://www.linkedin.com/in/your-profile)
-   Twitter: [Twitter Handle](https://twitter.com/your-handle)

Thank you for attending my presentation!
