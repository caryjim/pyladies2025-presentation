[
  {
    "objectID": "Presentation_PyLadies_CKJ.html#learning-outcomes",
    "href": "Presentation_PyLadies_CKJ.html#learning-outcomes",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Learning Outcomes",
    "text": "Learning Outcomes\n\nUnderstand when to use stratified sampling over random sampling\nLearn how to define subgroups (strata) and implement sampling in Python\nEvaluate sample representativeness by checking distribution patterns\nApply weights to adjust for unequal proportions in score estimation\n\nTodayâ€™s presentation\nDemonstrate how stratified random sampling to identify subgroups - Post-stratification weights are applied to correct unequal representation"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#stratified-sampling-why-and-when",
    "href": "Presentation_PyLadies_CKJ.html#stratified-sampling-why-and-when",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Stratified Sampling: Why and When?",
    "text": "Stratified Sampling: Why and When?\n\nChallenges in surveying large populations: time, budget, and resource constraints\nImportance of representative samples in research to reduce bias\nAlign research outcomes with actionable goals: informing policy, guiding interventions, or enhancing program effectiveness\nAllow for subgroup analysis to understand diverse perspectives within the population"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#overview",
    "href": "Presentation_PyLadies_CKJ.html#overview",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Overview",
    "text": "Overview\nStratified sampling is a research design method that involves dividing a population into smaller subgroups known as strata.\n\nStrata are formed based on shared attributes or characteristics (e.g., age group, gender, geographic location).\nA sampling technique, such as random, systematic, or convenience sampling, is then applied to select participants in each stratum.\n\nðŸ“˜ Examples\n\nSystematic sampling within strata: You divided a college students population based on their major and then select every kth element based on the size needed from each stratum.\nStratified random sampling within strata: You divided a college students population based on their major and then randomly select a proportionate number of students from each major."
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#population-dataset",
    "href": "Presentation_PyLadies_CKJ.html#population-dataset",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Population Dataset",
    "text": "Population Dataset\nIn this example, the population is defined as 25,000 college students.\nVariables in the population dataset:\n\n\nCode\nimport pandas as pd\ndata_folder = './Data Files/'\npopulation_data = pd.read_csv(data_folder + \"synthetic_students.csv\")\n\n# View the first three rows of the population dataset\npopulation_data.head(3)\n\n\n\n\n\n\n\n\n\nStudentID\nGender\nAge\nRace\nEthnicity\nStudentType\nOverallGPA\n\n\n\n\n0\nSID000001\nMale\n18\nWhite\nHispanic or Latino\nFreshman\n4.00\n\n\n1\nSID000002\nFemale\n40\nTwo or more races\nHispanic or Latino\nContinuing Education\n0.00\n\n\n2\nSID000003\nFemale\n19\nWhite\nNot Hispanic or Latino\nJunior\n3.23"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#cochrans-sample-size-formula",
    "href": "Presentation_PyLadies_CKJ.html#cochrans-sample-size-formula",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Cochranâ€™s Sample Size Formula",
    "text": "Cochranâ€™s Sample Size Formula\nThe ideal sample size for an infinite population is given by: \\[\nn_0 = \\frac{Z^2 \\, p \\, (1 - p)}{e^2}\n\\]\nwhere:\n\n( n0 ) = initial sample size from Cochranâ€™s formula for an infinite population\n( Z ) = Z-value (e.g., 1.96 for 95% confidence, z-table lookup)\n( p ) = estimated proportion of the attribute present in the population (assuming 0.5 for largest variability)\n( e ) = margin of error (e.g., 0.05 for 5%, the desired level of precision)\n\nThe sample size adjusted for a finite population is given by:\n\\[\nn = \\frac{n_0}{1 + \\left( \\frac{n_0 - 1}{N} \\right)}\n\\]\nwhere:\n\n( n ) = adjusted sample size for a finite population\n( n0 ) = theoretical sample value obtained from Cochranâ€™s formula for an infinite population\n( N ) = population size"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#code-example-cochrans-sample-size-calculation",
    "href": "Presentation_PyLadies_CKJ.html#code-example-cochrans-sample-size-calculation",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Code example: Cochranâ€™s Sample Size Calculation",
    "text": "Code example: Cochranâ€™s Sample Size Calculation\n\n\nCode\n# Cochran's Sample Size Calculation\nimport scipy.stats as stats\ndef cochran_sample_size(Z, p, e, N):\n    n0 = (Z**2 * p * (1 - p)) / (e**2)\n    n = n0 / (1 + ((n0 - 1) / N))\n    return int(n)\n\n# Parameters\nZ = stats.norm.ppf(0.975)   # Calculate the critical z-value for a 95% confidence level in a standard normal distribution\np = 0.5                     # Estimated proportion (use 0.5 for maximum variability, sort of like worst-case scenario)\ne = 0.05                    # Margin of error (precision level, more precision requires larger sample size)\nN = 25000                   # Finite population size (in this example, student population size)\n\n# Calculate sample size\n\n# Calculate n0 and adjusted sample size for finite population\nn0 = (Z**2 * p * (1 - p)) / (e**2)\nsample_size = n0 / (1 + ((n0 - 1) / N))\nprint(f\"Ideal sample size (n0): {round(n0)}\")\nprint(f\"Adjusted sample size for finite population: {int(sample_size)}\")\n\n\nIdeal sample size (n0): 384\nAdjusted sample size for finite population: 378"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#but-waittheres-re-coding-to-do",
    "href": "Presentation_PyLadies_CKJ.html#but-waittheres-re-coding-to-do",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "But Waitâ€¦Thereâ€™s Re-coding to Do!",
    "text": "But Waitâ€¦Thereâ€™s Re-coding to Do!\n\n\nExample 1: By increments of 2 or 10\n\n\nCode\n# Binding age groups by increments of 2 years for younger ages and 10 years for older ages\npopulation_data['Age_Group_1'] = pd.cut(population_data['Age'], \n                                       bins=[17, 19, 21, 23, 25, 27, 29, 31, 41, 50],\n                                       labels=['17-18', '19-20', '21-22', '23-24', '25-26', '27-28', '29-30', '31-40', '41-50'], right=False)\n# View the distribution after recoding for both counts and proportions\n# Make a list of two outputs: counts and proportions\n# To view counts\nage_1_group_counts = population_data['Age_Group_1'].value_counts().sort_index()\n# To view proportions\nage_1_group_proportions = population_data['Age_Group_1'].value_counts(normalize=True).sort_index().round(3)\nage_1_group_counts, age_1_group_proportions\n\n\n(Age_Group_1\n 17-18    10123\n 19-20     8896\n 21-22     4222\n 23-24      506\n 25-26      329\n 27-28      277\n 29-30      235\n 31-40      400\n 41-50       12\n Name: count, dtype: int64,\n Age_Group_1\n 17-18    0.405\n 19-20    0.356\n 21-22    0.169\n 23-24    0.020\n 25-26    0.013\n 27-28    0.011\n 29-30    0.009\n 31-40    0.016\n 41-50    0.000\n Name: proportion, dtype: float64)\n\n\n\nExample 2: By meaningful groups\n\n\nCode\n# We will keep the first three groups like the previous example, but then group all older ages into one group, as 31 and above.\n\npopulation_data['Age_Group_2'] = pd.cut(population_data['Age'], \n                                       bins=[17, 19, 21, 23, 25, 31, 44],\n                                       labels=['17-18', '19-20', '21-22', '23-25', '26-30', '31+'],\n                                   right=False)\n# View the distribution after recoding for both counts and proportions\n# To view counts\nage_2_group_counts = population_data['Age_Group_2'].value_counts().sort_index()\n# To view proportions\nage_2_group_proportions = population_data['Age_Group_2'].value_counts(normalize=True).sort_index().round(3)\nage_2_group_counts, age_2_group_proportions\n\n\n(Age_Group_2\n 17-18    10123\n 19-20     8896\n 21-22     4222\n 23-25      506\n 26-30      841\n 31+        411\n Name: count, dtype: int64,\n Age_Group_2\n 17-18    0.405\n 19-20    0.356\n 21-22    0.169\n 23-25    0.020\n 26-30    0.034\n 31+      0.016\n Name: proportion, dtype: float64)\n\n\n\nReminder: The proportion of each subgroup should be calculated after re-coding. If you adjust any levels within a variable, it can affect the distribution of values in the dataset. In practice, you may repeat this step until you are able to draw a proper set of subgroups before creating the strata."
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#calculate-proportions",
    "href": "Presentation_PyLadies_CKJ.html#calculate-proportions",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Calculate Proportions",
    "text": "Calculate Proportions\nThe strata (subgroups) are determined by the following categories:\n\nGender (Female or Male)\nRace (Asian, Black or African American, White, Two or more races, Other)\nAge Group (16-18, 19-20, 21-22, 23-30, 31+)\n\nCode example: Proportion by each stratum\n\n\nCode\n# Create a distribution chart for each of the three variables after recoding\nimport matplotlib.pyplot as plt\n\n# Proportion of Gender in the Sample Selection Data and add the proportion on top of each bar\ngender_proportions = sample_selection_data['Gender_m'].value_counts(normalize=True).round(2)\ngender_proportions.plot(kind='bar', title='Proportion of Gender')\nplt.xticks(rotation=0)\n# Round to 2 decimal places and convert to percentage\nfor i, v in enumerate(gender_proportions):\n    plt.text(i, v + 0.01, str(round(v * 100, 2)) + '%', ha='center')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Proportion of Race in the Sample Selection Data\nrace_proportions = sample_selection_data['Race_m'].value_counts(normalize=True).round(2)\nrace_proportions.plot(kind='bar', title='Proportion of Race')\nplt.xticks(rotation=0)\n# Round to 2 decimal places and convert to percentage\nfor i, v in enumerate(race_proportions):\n    plt.text(i, v + 0.01, str(round(v * 100, 2)) + '%', ha='center')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Proportion of Age Group in the Sample Selection Data\nage_proportions = sample_selection_data['Age_Group_2'].value_counts(normalize=True).round(2)\nage_proportions.plot(kind='bar', title='Proportion of Age Group')\nplt.xticks(rotation=0)\nfor i, v in enumerate(age_proportions):\n    plt.text(i, v + 0.01, str(round(v * 100, 2)) + '%', ha='center')\nplt.show()"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#re-sampling",
    "href": "Presentation_PyLadies_CKJ.html#re-sampling",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Re-sampling",
    "text": "Re-sampling\n\n\nCode\n# This time we are using a different set of parameters. The formula remains the same from Step 2.\n# Parameters\nZ = stats.norm.ppf(0.975)   # Calculate the critical z-value for\n# a 95% confidence level in a standard normal distribution\np = 0.5                     # Estimated proportion (use 0.5 for maximum variability, sort of like worst-case scenario)\ne_3 = 0.03                    # Margin of error (precision level, more precision requires larger sample size)\nN = 25000                   # Finite population size (in this example, student population size)\n\n# Calculate sample size\n# Calculate n0 and adjusted sample size for finite population\nn0 = (Z**2 * p * (1 - p)) / (e_3**2)\nsample_size_larger_e = n0 / (1 + ((n0 - 1) / N))\nprint(f\"Ideal sample size (n0) for 95% confidence level with 3% margin of error: {round(n0)}\")\nprint(f\"Adjusted sample size of finite population for 95% confidence level with 3% margin of error: {int(sample_size_larger_e)}\")\n\n\nIdeal sample size (n0) for 95% confidence level with 3% margin of error: 1067\nAdjusted sample size of finite population for 95% confidence level with 3% margin of error: 1023\n\n\nThen, we apply the proportions to get the sample of this updated sample size.\n\n\nCode\n# Determine the combined proportions of the strata in the sample selection data with the modified variables\nstratum_set_1 = sample_selection_data.groupby(['Gender_m', 'Race_m', 'Age_Group_2'], observed=True).size().reset_index(name='Count')\nstratum_set_1['Proportion'] = stratum_set_1['Count'] / stratum_set_1['Count'].sum()\n\n# use the 3% sample size to draw the stratified random sample\nstratum_sizes_three_moe = (stratum_set_1['Proportion'] * int(sample_size_larger_e)).round().astype(int)\n# Add the grouping variables back to the stratum sizes DataFrame for clarity\nstratum_sizes_three_moe = pd.concat([stratum_set_1[['Gender_m', 'Race_m', 'Age_Group_2']], stratum_sizes_three_moe.rename('Sample_Size')], axis=1)\nprint(\"Stratum sizes for each subgroup based on 3% margin of error sample size (first 3 rows):\")\nstratum_sizes_three_moe.head(3)\n\n\nStratum sizes for each subgroup based on 3% margin of error sample size (first 3 rows):\n\n\n\n\n\n\n\n\n\nGender_m\nRace_m\nAge_Group_2\nSample_Size\n\n\n\n\n0\nFemale\nAsian\n17-18\n25\n\n\n1\nFemale\nAsian\n19-20\n21\n\n\n2\nFemale\nAsian\n21-22\n10\n\n\n\n\n\n\n\nDraw the stratified random sample based on the calculated stratum sizes.\n\n\nCode\n# Initialize an empty list to hold sampled dataframes\nsampled_groups = []\nfor i, row in stratum_sizes_three_moe.iterrows():\n    stratum_filter = (\n        (sample_selection_data['Gender_m'] == row['Gender_m']) &\n        (sample_selection_data['Race_m'] == row['Race_m']) &\n        (sample_selection_data['Age_Group_2'] == row['Age_Group_2'])\n    )\n    stratum_population = sample_selection_data[stratum_filter]\n    # Use the sample size from the current row\n    stratum_sample_size = int(row['Sample_Size'])\n\n    # Ensure we don't sample from empty strata or more than available\n    n = min(stratum_sample_size, len(stratum_population))\n    if n &gt; 0:\n        stratum_sample = stratum_population.sample(n=n, replace=False)\n        sampled_groups.append(stratum_sample)\n\n# Combine all sampled dataframes into a single dataframe (guard against empty list)\nif sampled_groups:\n    sampled_dataset = pd.concat(sampled_groups).reset_index(drop=True)\nelse:\n    sampled_dataset = pd.DataFrame(columns=sample_selection_data.columns)\n\n# Create an alias expected by downstream cells and align column naming\nsampled_data = sampled_dataset.copy()\nif 'Age_Group' not in sampled_data.columns and 'Age_Group_2' in sampled_data.columns:\n    sampled_data['Age_Group'] = sampled_data['Age_Group_2']\n# View the first three rows of the sampled dataset\nprint(\"Sampled dataset (first 3 rows):\")\nsampled_data[['StudentID', 'Gender_m', 'Race_m', 'Age_Group']].head(3)\n\n\nSampled dataset (first 3 rows):\n\n\n\n\n\n\n\n\n\nStudentID\nGender_m\nRace_m\nAge_Group\n\n\n\n\n0\nSID007881\nFemale\nAsian\n17-18\n\n\n1\nSID022984\nFemale\nAsian\n17-18\n\n\n2\nSID015053\nFemale\nAsian\n17-18"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#compare-sample-proportions-to-population-proportions",
    "href": "Presentation_PyLadies_CKJ.html#compare-sample-proportions-to-population-proportions",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Compare Sample Proportions to Population Proportions",
    "text": "Compare Sample Proportions to Population Proportions\nStratum are indexed based on the order in the DataFrame.\n\n\nSampled Dataset (n = 1024)\n\n\nCode\nprint(\"Sampled dataset size:\", len(sampled_dataset))\n\n# Calculate the proportions in the sampled data\nsample_proportions = sampled_dataset.groupby(['Gender_m', 'Race_m', 'Age_Group_2'], observed=True).size().reset_index(name='Count')\nsample_proportions['Proportion'] = sample_proportions['Count'] / sample_proportions['Count'].sum()\n# View the distribution of the sampled data in a chart\nimport matplotlib.pyplot as plt\n# Chart for Sampled Data Proportions\nplt.figure(figsize=(5, 3))\nplt.bar(range(len(sample_proportions)), sample_proportions['Proportion'])\nplt.title('Sampled Data Proportions by Stratum')\nplt.xlabel('Stratum Index')\nplt.ylabel('Proportion')\nplt.xticks(range(len(sample_proportions)), sample_proportions.index, rotation=90)\nplt.tight_layout()\nplt.show()\n# Display the sampled proportions DataFrame\nsample_proportions[['Proportion']].round(3).head(5)\n\n\nSampled dataset size: 1024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProportion\n\n\n\n\n0\n0.024\n\n\n1\n0.021\n\n\n2\n0.010\n\n\n3\n0.001\n\n\n4\n0.002\n\n\n\n\n\n\n\n\nPopulation Dataset (N = 25,000)\n\n\nCode\nprint(\"population:\", len(sample_selection_data))\n\n# Calculate the proportions in the population data\npopulation_proportions = sample_selection_data.groupby(['Gender_m', 'Race_m', 'Age_Group_2'], observed=True).size().reset_index(name='Count')\npopulation_proportions['Proportion'] = population_proportions['Count'] / population_proportions['Count'].sum()\n# View the distribution of the population data in a chart\nplt.figure(figsize=(5, 3))\nplt.bar(range(len(population_proportions)), population_proportions['Proportion'])\nplt.title('Population Data Proportions by Stratum')\nplt.xlabel('Stratum Index')\nplt.ylabel('Proportion')\nplt.xticks(range(len(population_proportions)), population_proportions.index, rotation=90)\nplt.tight_layout()\nplt.show()\n# Display the population proportions DataFrame\npopulation_proportions[['Proportion']].head(5).round(3)\n\n\npopulation: 25000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProportion\n\n\n\n\n0\n0.024\n\n\n1\n0.021\n\n\n2\n0.010\n\n\n3\n0.001\n\n\n4\n0.002\n\n\n\n\n\n\n\n\nOnce verified, the sampled dataset can be used for survey distribution."
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#post-stratification-weights",
    "href": "Presentation_PyLadies_CKJ.html#post-stratification-weights",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Post-Stratification Weights",
    "text": "Post-Stratification Weights\n\nEssential when sample proportions differ from population proportions.\nCorrects over- or under-representation of certain groups and improves accuracy and validity of survey results.\n\nPost-Stratification weights can be calculated in different ways:\n\nEach stratum individually\nCombined categories (joint distribution considered)\nNote. weights can be a fraction, but are always positive and non-zero.\n\nTodayâ€™s demonstration is similar to individual strata weighting but accounts for joint distribution."
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#weights-calculation-formula",
    "href": "Presentation_PyLadies_CKJ.html#weights-calculation-formula",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Weights Calculation Formula",
    "text": "Weights Calculation Formula\nEach weight is determined by dividing the sample proportion by the respondent proportion of each variable. Then, multiply the variable weights together to get the overall weight for each respondent.\nIn general, the formula for calculating weight for each variable is:\n\\[\n\\text{Weight} = \\dfrac{\\text{Sample Proportion}}{\\text{Respondent Proportion}}\n\\]\nBecause we used a combination of variables in the strata, each participant should be assigned an overall weight:\n\\[\nW_{\\text{overall}} = W_{\\text{race}} \\times W_{\\text{gender}} \\times W_{\\text{age}}\n\\]\nThe overall weight assigned to each respondent is then used in survey item analysis."
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#overall-weight-calculation",
    "href": "Presentation_PyLadies_CKJ.html#overall-weight-calculation",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Overall Weight Calculation",
    "text": "Overall Weight Calculation\nThis table shows an example of weight calculation for a respondent (rounded to 3 decimal places for illustration purposes):\n\n\n\n\n\n\n\n\n\n\nVariables\nParticipant Value\nSample Proportion\nRespondent Proportion\nVariable weight = sample_p/respondent_p\n\n\n\n\nGender\nFemale\n.574\n.631\n.910\n\n\nAge Group\n17-18\n.404\n.261\n1.548\n\n\nRace\nWhite\n.568\n.556\n1.022\n\n\n\nThe final weight for this respondent is \\[\n0.910*1.548*1.022 = 1.439\n\\]"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#respondents-dataset",
    "href": "Presentation_PyLadies_CKJ.html#respondents-dataset",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Respondents Dataset",
    "text": "Respondents Dataset\nSynthetic respondents data based on a survey distributed to the sampled dataset.\nThere are 241 respondents in the survey results.\n\n\nCode\nimport pandas as pd\ndata_folder = './Data Files/'\n# Import the respondents data file (synthetic respondents data based on a survey)\nrespondents_data = pd.read_excel(data_folder + 'respondents_file.xlsx')\n# Make the output view smaller for presentation\nprint(\"Respondents dataset (first 3 rows):\")\nrespondents_data[:3]\n\n\nRespondents dataset (first 3 rows):\n\n\n\n\n\n\n\n\n\nQ1_Gender\nQ2_Race\nQ3_AgeGroup\nQ4_Traffic_Accidents\nQ5_Academic_Performance\n\n\n\n\n0\nMale\nWhite\n17-18\n4.0\n4.0\n\n\n1\nFemale\nWhite\n17-18\n3.0\n3.0\n\n\n2\nFemale\nWhite\n17-18\n5.0\n5.0"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#calculate-weights",
    "href": "Presentation_PyLadies_CKJ.html#calculate-weights",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Calculate Weights",
    "text": "Calculate Weights\n\n\nCode\n# Recall the propotions from the sampled data\nsampled_data_proportions = {\n    \"gender_sampled\": sampled_dataset['Gender_m'].value_counts(normalize=True).round(3).to_dict(),\n    \"race_sampled\": sampled_dataset['Race_m'].value_counts(normalize=True).round(3).to_dict(),\n    \"age_group_sampled\": sampled_dataset['Age_Group_2'].value_counts(normalize=True).round(3).to_dict()\n}\n\n## Calculate the respondents demographic proportions of the three variables: Gender, Race, and Age Group and create a dictionary by the propotion and round to three decimal places\nrespondent_proportions = {\n    \"Gender_r\": respondents_data['Q1_Gender'].value_counts(normalize=True).round(3).to_dict(),\n    \"Race_r\": respondents_data['Q2_Race'].value_counts(normalize=True).round(3).to_dict(),\n    \"Age_Group_r\": respondents_data['Q3_AgeGroup'].value_counts(normalize=True).round(3).to_dict()\n}\n\n# Define the two dictionaries for population and respondents proportions\npopl_dict = sampled_data_proportions\nresp_dict = respondent_proportions\n\n# Using each of the labels in the variables, then the population or respondent proportions can be retrieved from the dictionaries.\n# For example, if Q1_Gender is 'Female', then the population proportion of 0.574 will be retrieved.\n# Then, the respondent proportion, 'Gender_r' of 0.631 will be retrieved for the denominator.\n\n# Now we can calculate the weights for each respondent based on the three variables\ndef calculate_weight(row, popl_dict, resp_dict):\n    gender_weight = popl_dict['gender_sampled'].get(row['Q1_Gender'], 0) / resp_dict['Gender_r'].get(row['Q1_Gender'], 1)\n    race_weight = popl_dict['race_sampled'].get(row['Q2_Race'], 0) / resp_dict['Race_r'].get(row['Q2_Race'], 1)\n    age_group_weight = popl_dict['age_group_sampled'].get(row['Q3_AgeGroup'], 0) / resp_dict['Age_Group_r'].get(row['Q3_AgeGroup'], 1)\n    total_weight = gender_weight * race_weight * age_group_weight\n    return total_weight\n\n\nPreview the weights calculated for the first three respondents.\n\n\nCode\n# Apply the weight calculation to each row in the respondents_data DataFrame\nrespondents_data['O_Weight'] = respondents_data.apply(calculate_weight, axis=1, args=(popl_dict, resp_dict))\n# View the first three rows with the calculated weights\nprint(\"Respondents data with calculated weights (first 3 rows, rounded to 3 decimal places):\")  \nrespondents_data[['Q1_Gender', 'Q2_Race', 'Q3_AgeGroup', 'O_Weight']].head(3).round(3)\n\n\nRespondents data with calculated weights (first 3 rows, rounded to 3 decimal places):\n\n\n\n\n\n\n\n\n\nQ1_Gender\nQ2_Race\nQ3_AgeGroup\nO_Weight\n\n\n\n\n0\nMale\nWhite\n17-18\n1.830\n\n\n1\nFemale\nWhite\n17-18\n1.442\n\n\n2\nFemale\nWhite\n17-18\n1.442\n\n\n\n\n\n\n\nNote. Due to decimal rounding, some weights will be slightly different from manual calculations in the previous slide."
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#apply-weights-to-survey-item",
    "href": "Presentation_PyLadies_CKJ.html#apply-weights-to-survey-item",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Apply Weights to Survey Item",
    "text": "Apply Weights to Survey Item\nQuestion: On a scale from 0-5, how often does drug abuse lead to traffic accidents among college students?\nScale: 0 - Never to 5 - Very Often\n\n\nCode\n# Apply the weight calculation to each row in the respondents_data DataFrame\nrespondents_data['Q4_with_weights'] = respondents_data['Q4_Traffic_Accidents'] * respondents_data['O_Weight']\n# View the first three rows with the calculated weighted scores\nprint(\"Respondents data with weighted Q4_Traffic_Accidents scores (first 3 rows, rounded to 3 decimal places):\")  \nrespondents_data[['Q4_Traffic_Accidents', 'O_Weight', 'Q4_with_weights']].head(3).round(3)\n\n\nRespondents data with weighted Q4_Traffic_Accidents scores (first 3 rows, rounded to 3 decimal places):\n\n\n\n\n\n\n\n\n\nQ4_Traffic_Accidents\nO_Weight\nQ4_with_weights\n\n\n\n\n0\n4.0\n1.830\n7.320\n\n\n1\n3.0\n1.442\n4.326\n\n\n2\n5.0\n1.442\n7.210\n\n\n\n\n\n\n\nNext, we can compare the non-weighted mean to the weighted mean of the survey item.\n\n\nCode\ntraffic_accident_response = respondents_data[['Q4_Traffic_Accidents', 'Q4_with_weights']].copy()\nnon_weighted_mean = traffic_accident_response['Q4_Traffic_Accidents'].mean()\nweighted_mean = traffic_accident_response['Q4_with_weights'].mean()\nprint(f\"Non-weighted mean of Q4_Traffic_Accidents: {non_weighted_mean:.3f}\")\nprint(f\"Weighted mean of Q4_Traffic_Accidents: {weighted_mean:.3f}\")\n\n\nNon-weighted mean of Q4_Traffic_Accidents: 4.606\nWeighted mean of Q4_Traffic_Accidents: 4.940"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#distribution-of-non-weighted-and-weighted-scores",
    "href": "Presentation_PyLadies_CKJ.html#distribution-of-non-weighted-and-weighted-scores",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Distribution of Non-Weighted and Weighted Scores",
    "text": "Distribution of Non-Weighted and Weighted Scores\nVisual comparison of the non-weighted and weighted scores with histogram:\n\n\nCode\n# Visual comparison of non-weighted vs weighted means with histogram\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(8, 5))\nplt.clf()  # Clear any previous plots\n\n# Histogram of non-weighted responses\nn, bins, patches = plt.hist(\n    respondents_data['Q4_Traffic_Accidents'],\n    bins=6,\n    alpha=0.5,\n    label='Non-weighted',\n    color='blue',\n    edgecolor='black'\n)\n\n# Histogram of weighted responses\nn_w, bins_w, patches_w = plt.hist(\n    respondents_data['Q4_with_weights'],\n    bins=6,\n    alpha=0.5,\n    label='Weighted',\n    color='orange',\n    edgecolor='black'\n)\n\nplt.xlabel('Q4_Traffic_Accidents (0=Never, 5=Very Often)')\nplt.ylabel('Frequency')\nplt.title('Distribution of Q4_Traffic_Accidents Responses')\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nThe weighted mean makes the value more distributed than the non-weighted mean because it accounts for the under-represented groups in the respondents data by assigning different weights by their proportions in the sampled data.\nHigher weights have higher impact on the overall mean and will have a greater influence on the weighted mean calculation.\n\nThe distribution of responses is more balanced after applying weights, indicating that the weighted mean better reflects the population characteristics.\n\n\nCode\nrespondents_data[['Q4_Traffic_Accidents', 'Q4_with_weights']].describe().round(3)\n\n\n\n\n\n\n\n\n\nQ4_Traffic_Accidents\nQ4_with_weights\n\n\n\n\ncount\n203.000\n203.000\n\n\nmean\n4.606\n4.940\n\n\nstd\n0.753\n2.345\n\n\nmin\n1.000\n0.174\n\n\n25%\n4.000\n3.635\n\n\n50%\n5.000\n4.723\n\n\n75%\n5.000\n6.022\n\n\nmax\n5.000\n10.561"
  },
  {
    "objectID": "Presentation_PyLadies_CKJ.html#presentation-details-in-conference-program",
    "href": "Presentation_PyLadies_CKJ.html#presentation-details-in-conference-program",
    "title": "Stratified Sampling in Survey Research with Python",
    "section": "Presentation Details in Conference Program",
    "text": "Presentation Details in Conference Program\nAbstract: Stratified sampling helps ensure representative data subsets, especially when working with imbalanced groups. In this talk, weâ€™ll explore its use in survey analysis, demonstrate a Python-based implementation, and share best practices for improving data reliability and reducing bias. Attendees will gain a clear understanding of when and how to use stratified sampling effectively in real-world scenarios.\nDescription: Whether youâ€™re conducting surveys, building predictive models, or working with imbalanced datasets, stratified sampling is a powerful technique for ensuring your data is representative and your insights are reliable.\nIn survey research, particularly with diverse populations like college students, simple random sampling can lead to under-representation of key subgroups. Stratified sampling addresses this by dividing the population into distinct strata (e.g., age groups, majors, demographics) and sampling proportionally from each. This approach reduces sampling bias and improves the reliability of statistical estimates.\nIn this presentation, I will demonstrate how to use Python to implement stratified sampling in a student survey at our college. By maintaining proportional representation across age groups, we ensured that our sample reflected the diversity of the student body. Iâ€™ll walk through the conceptual foundations of stratified sampling, compare it with simple random sampling, and highlight its advantages in survey research and data analysis.\nWeâ€™ll also explore how to calculate weighted means when sample proportions differ from population proportions, which is a crucial step in producing unbiased estimates. Code examples and visualizations will be shared via GitHub to support hands-on learning and reproducibility."
  }
]